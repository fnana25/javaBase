1、逃逸分析：
判断依据：对象是否存入堆中；对象是否被传入未知代码中。
基于逃逸分析的优化：锁消除、对象栈上分配（标量替换）。
标量替换及原本连续分配的对象拆散为一个个单独的字段，分配在栈中或寄存器中，去掉对象头。

2、内存溢出与内存泄漏的区别：
内存溢出：系统不能分配所需的内存空间了。
内存泄漏：内存资源用完后没有回收。
内存溢出的原因：
   内存中加载的数据量太大；
   集合类中有对象的引用，使用完后未清空，使jvm不能回收；
   代码中产生死循环，或循环产生过多对象；
   启动参数的内存值设置得太小
 解决办法：
   修改jvm启动参数，增加内存（-xms,-xmx)
   检查错误日志
   检查代码
   使用工具查看内存使用情况

3、编译时/运行时
   以下发生在编译时：
   常量折叠，final 的常量在编译时替换为具体数值；
   泛型，编译器负责检查程序中类型的正确性，这个技术被称为“类型擦除“；
   方法重载；
   编译时注解；
   异常检查；
   aop编译时织入；
   继承；

4、解释执行与编译执行
   解释执行：将编译好的字节码一行一行地翻译为机器码执行。
   优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行
   编译执行：以方法为单位，将字节码一次性翻译为机器码后执行。
   优势：当程序运行后，随着时间的推移，编译器会逐渐失去作用，把越来越多的代码编译成本地代码后，可以获得更好的执行效率

5、编译过程
  词法分析：将源代码的字符流转变为标记（Token）集合，关键字、变量名、字面量、运算符等都可以成为标记
  语法分析：根据Token序列来构造抽象语法树的过程。
           抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如类型、修饰符、运算符等。
  语义分析：对结构上正确的源程序进行上下文有关性的审查。
  语义分析过程分为标注检查和数据及控制流分析两个步骤：
     标注检查的内容包括诸如：变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。
     数据及控制流分析是对程序上下文逻辑更进一步的验证，
     检查出诸如:程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。
  字节码生成：把前面各个步骤所生成的信息转化成字节码写到磁盘中。
  jvm执行字节码过程：
    加载：查找并加载类的二进制数据到内存中（首次主动使用时才加载，7种主动使用情况）
    连接：-验证（确保加载类的正确性）；-准备（为类的静态变量分配内存，设置默认值）；-解析（把类中的符号引用转变为直接引用）
    初始化：为类的静态变量赋予正确的初始值
  解释+编译执行

字节码优势：在一定程度上解决了传统的解释性语言执行效率低的问题，同时又保留了解释性语言的可移植性
jdk1.7及之后运行时常量池从方法区移到了堆

Java 虚拟机栈：
    Java虚拟机栈是线程私有的，它的生命周期随线程启动时创建，销毁时销毁，它用来存储Java方法运行时的数据（局部变量、操作数栈动态链接和方法出口信息）
    局部变量表主要存放方法参数和方法内部定义的局部变量，如果是基本类型，存放的是变量的值，如果是引用类型存放的是变量的引用
缓存行与伪共享：
    几个在逻辑上并不包含在同一个内存单元内的数据，由于被CPU加载到同一个缓存行当中，当在多线程的环境下，被不同的cpu执行导致缓存行失效而引起的大量缓存命中问题。
    解决伪共享的一个方法是让一个数据占据一个缓存行

一行代码的执行流程：
    Java编译器将代码编译成字节码，jvm通过类加载器加载字节码，解释器将字节码解释成汇编指令（jit可以直接将一段字节码解释成机器码），最终转义成机器指令
一个线程抛oom了，其他线程是否还会继续执行：
    oom后，jvm会进行一次full gc,如果gc后有空闲空间了或者其他线程没有创建对象，还是可以继续运行，不过此时cpu会用大量的时间去做gc。

以下情况需要jvm调优：
    1.堆内存（老年代）持续上涨达到设备的最大内存值；
    2.full gc频繁；
    3.gc时间过长（超过1秒）；
    4.系统出现oom等内存异常；
    5.应用中有使用本地缓存，且占用大量内存空间；
    6.系统吞吐量与响应性能不高或下降

jvm调优基本原则：
    1.大多数的java应用不需要进行jvm调优；
    2.大多数导致gc问题的原因是代码层面的问题导致的；
    3.上线之前，应先考虑将机器的jvm参数设置到最优；
    4.减少创建对象的数量（代码层面）；
    5.减少使用全局变量和大对象（代码层面）；
    6.优先架构调优和代码调优，jvm优化是不得已的手段（代码、架构层面）；
    7.分析gc情况，优化代码比优化jvm参数更好（代码层面）
调优工具介绍：https://blog.csdn.net/ityouknow/article/details/56844837

到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel old

jvm调优参数：
    -Xmx: 最大堆内存，如-Xmx512m
    -Xms: 初始堆内存，如-Xms256m
    -XX:MaxNewSize: 最大年轻区内存
    -XX:NewSize: 初始时年轻区内存通常为最大堆内存的1/3或1/4。新生代 = Eden + 2个Survivor空间。实际可用空间 = Eden + 1个Survivor
    -XX:MaxPermSize: 最大持久代内存
    -XX:PermSize: 初始持久代内存
    -XX:+PrintGCDetails: 打印gc信息
    -XX:NewRatio: 新生代与老年代的比例。如XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3
    -XX:SurvivorRatio: 新生代中Eden与Survivor的比值。默认为8，即Eden占新生代空间的8/10，另外两个Survivor各占1/10
    设置垃圾收集器：
        -XX:+UseSerialGC: 设置串行收集器
        -XX:+UserParallelGC: 设置并行收集器
        -XX:+UserParallelGC: 设置并行老年代收集器
        -XX:+UseConMarkSweepGC: 设置并发收集器






















