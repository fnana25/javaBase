Redis最新版本：5.0.7

常见问题总结：
redis/缓存的作用(高并发/高可用)——》redis线程模型——》与memcached的区别——》常见数据结构及应用——》过期时间与淘汰机制——》持久化机制——》雪崩/穿透

redis线程模型（单线程），使用单线程的原因：
1)单线程模型带来更好的可维护性，方便开发和调试；（多线程引入了程序执行顺序的不确定性，需要增加并发控制来确保数据的正确性）
2)使用单线程模型也能并发地处理客户端请求；（redis使用IO多路复用机制并发处理来自客户端的多个连接请求）
3)redis中绝大多数数据操作的性能瓶颈不在CPU；（redis不是CPU密集型的服务，redis操作在内存中完成的，不会涉及io操作，redis的性能瓶颈在网络io）

4.0版本之后执行一些命令会使用主线程之外的其他线程（如耗时比较长的大键值对删除操作）

redis事务：
    redis提供了一种将多个命令请求打包，然后一次性按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求。redis同一个
    事务中，如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。
雪崩：同一时间，缓存大面积的失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量的请求而崩掉
解决办法：
    事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略；
    事中：本地缓存+限流/降级，避免数据库崩掉；
    事后：利用redis持久化机制保存的数据尽快恢复缓存
穿透：一般是黑客故意去请求缓存中不存在的数据，导致所有的数据都落在数据库上，造成数据库短时间内承受大量的请求而崩掉
    解决办法：有很多种办法可以解决缓存穿透问题，最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap
    拦截掉，从而避免了对底层数据存储的查询压力。另外有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），任然把这个空结果
    进行缓存，但它的过期时间很短，最长不超过5分钟。

    同时，其可以避免服务宕机导致的锁无法释放，而产生死锁问题。完成业务流程后，删除对应的子节点释放锁

如何保证缓存与数据库双写时的数据一致性：
    读请求和写请求串行化，串到一个内存队列中去，这样就能保证一定不会出现不一致的情况

