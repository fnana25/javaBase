
一条SQL查询语句是如何执行的
MySQL 可以分为 Server 层和存储引擎层两部分。
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），
所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。存储引擎层负责数据的存储和提取， InnoDB从 MySQL 5.5.5 版本开始成为了默认存储引擎。
查询缓存：命中则直接返回结果；查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。MySQL 8.0 版本直接将查询缓存的整块功能删掉了
连接器：管理连接，权限验证；
分析器：词法分析，语法分析；
优化器：执行计划生产，索引选择；
执行器：操作引擎，返回结果；
存储引擎：存储数据，提供读写接口

一条SQL更新语句是如何执行的？
redo log（重做日志）和 binlog（归档日志）的不同：
1、redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；
2、binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3、redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，
有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

事务隔离
当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题，所以就产生了隔离级别；
sql的标准隔离级别包括读未提交、读已提交、可重复读，串行化；

隔离的实现：
事务隔离是在存储引擎层实现的，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
- “读未提交”隔离级别下，直接返回记录上的最新值，没有视图概念；
- “读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；
- “可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图（mvcc多版本并发控制）；
- “串行化”隔离级别下，直接用加锁的方式来避免并行访问。

索引：
索引的常见模型有哈希表、有序数组和索引树
哈希表适合等值查询的场景；有序数组只适用于读多写少的等值查询和范围查询；索引树读写性能都好``````
innodb索引：
每一个索引在 InnoDB 里面对应一棵 B+ 树，分为主键索引和非主键索引，基于非主键索引的查询需要多扫描一棵主键索引树。
自增主键的好处：
每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂；
主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也越小；
b+树的好处：
B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。


回表：
回到主键索引树搜索的过程
覆盖索引：
如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，
不用回表操作，直接返回结果，减少IO磁盘读写读取整行数据。
联合索引：
也可以用到覆盖索引，不再需要回表查整行记录；
索引下推：
MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
最左前缀原则：
联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符，
如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

锁：
全局锁和表锁：
根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁。
全局锁（Flush tables with read lock (FTWRL)）：
顾名思义，全局锁就是对整个数据库实例加锁。
- 全局锁的典型使用场景是，做全库逻辑备份
缺点：在主库备份会导致更新语句阻塞，业务不可用；在从库备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致数据不一致
- 官方自带的逻辑备份工具 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，
导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
缺点：只适用于支持事务的引擎
- set global readonly=true方式
缺点：该值在某些场景用来判断数据库是否为主从库；如果客户端连接异常，数据库依然保持readonly状态，会导致数据库长时间不可写。
表级锁（lock tables … read/write）/ MDL（metadata lock)
当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。
如何安全的给小表加字段？
在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，
拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

怎么减少行锁对性能的影响？
两阶段协议：
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
死锁解决办法：
- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置（默认50s）。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

普通索引和唯一索引，应该怎么选择？
查询过程的区别：唯一索引查询到符合条件的数据就不会继续查找了，普通索引会继续查找下一条数据，直到不满足条件。（性能差别微乎其微，因为innoDB读数据是按数据页读取）
更新过程：如果要更新的数据页还没加载到内存中，innoDB会将更新操作缓存到change buffer中，当下次数据加载到内存中时再执行更新操作。
唯一索引需要判断key值是否冲突必须得将数据页读入内存判断，因此不能使用change buffer。
redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发优先考虑非唯一索引。

MySQL为什么有时候会选错索引？
优化器会根据分析查询语句的扫描行数，是否使用临时表，是否排序，回表代价等来选择最优索引
怎么给字符串字段加索引？
直接创建完整索引，这样可能比较占用空间；
创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

sql语句变慢原因（flash内存页到磁盘）？
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”
触发flash过程的几种情况：
1、redo log 写满了；
2、系统内存不够用；
3、数据库空闲的时候；
4、数据库关闭。

为什么表数据删掉一般表文件大小不变？
一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。
而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。
数据的删除流程：
InnoDB 的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，数据页就可以复用了。
delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的
重建表可以收缩空间
重建表的两种方式：
alter table A engine=InnoDB
Online DDL
Online DDL 的方式是可以考虑在业务低峰期使用的，而 MySQL 5.5 及之前的版本，这个命令是会阻塞 DML 的，这个你需要特别小心

count(*)为什么这么慢？
myIsam记录了表的总行数，innodb需要一行一行读取计数（会选择数据量最小的索引树读取）
避免使用count(*)的方法：
用缓存系统保存计数；缺点：两个不同存储构成的系统，不支持分布式事务，无法拿到精确一致的视图
在数据库保存计数。可以利用事务解决一致性
count()效率比较：
count(字段)<count(主键 id)<count(1)≈count(*)

order by是如何工作的？
explain 命令Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。
全字段排序
初始化 sort_buffer，确定放入 name、city、age 这三个字段；
从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
从索引 city 取下一个记录的主键 id；
重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；
对 sort_buffer 中的数据按照字段 name 做快速排序；
按照排序结果取前 1000 行返回给客户端。
rowid排序  （如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差）
初始化 sort_buffer，确定放入两个字段，即 name 和 id；
从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；
从索引 city 取下一个记录的主键 id；
重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；
对 sort_buffer 中的数据按照字段 name 进行排序；
遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。

MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。

为什么这些sql的逻辑相同性能却相差巨大？
1、条件字段函数操作
2、隐式类型转换
3、隐式字符编码转换
结论：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。

为什么只查一行的语句，也执行这么慢？
第一类：查询长时间不返回
1、等 MDL 锁
2、等 flush
3、等行锁
第二类：查询慢
一致性读，执行undo log ，可以使用lock in share mode，采用当前读模式快速返回。

幻读是什么，幻读会导致什么问题？
幻读仅专指“新插入的行”，即使把所有的记录都加上锁，还是阻止不了新插入的记录
如何解决幻读？
行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。
间隙锁在可重复读隔离级别下才有效
间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的

MySQL是怎么保证数据不丢的？
只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复
binlog 的写入机制：
事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。
redo log 的写入机制：
InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。

MySQL是怎么保证主备一致的？
主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。
备库 B 跟主库 A 之间维持了一个长连接。
1、在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。
2、在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。
3、主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。
4、备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。
5、sql_thread 读取中转日志，解析出日志里的命令，并执行。
binlog 的三种格式对比：
statement： binlog 里的是语句原文 可能会导致主备不一致
row：比较占空间
mixed： MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式
用 binlog 来恢复数据的标准做法是，用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行

MySQL是怎么保证高可用的？
正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。
但是最终一致性是不够的。
主备延迟：
主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。
延迟主要来源：
1、备库所在机器的性能要比主库所在的机器性能差
2、备库的压力大
3、大事务

备库为什么会延迟好几个小时？
如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。
采用并行复制策略可以缩小延迟时间
在官方的 5.6 版本之前，MySQL 只支持单线程复制，

主库出问题了，从库怎么办？
1、基于位点的主备切换
2、基于 GTID 的主备切换

读写分离有哪些坑？
怎么处理过期读问题：
1、强制走主库方案；对于必须要拿到最新结果的请求，强制将其发到主库上，对于可以读到旧数据的请求，才将其发到从库上。
2、sleep 方案；主库更新后，读从库之前先 sleep 一下。
3、判断主备无延迟方案；每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。
4、配合 semi-sync 方案；表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。
5、等主库位点方案；
6、等 GTID 方案。

如何判断一个数据库是不是出问题了？
1、select 1
在 InnoDB 中，innodb_thread_concurrency 这个参数的默认值是 0,建议把 innodb_thread_concurrency 设置为 64~128 之间的值。
在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙锁）的线程是不算在 innodb_thread_concurrency 里面的。
select 1 语句没有用到innodb所以不准确。
2、查表判断 建立一张表，插入一条语句，定期执行查询语句。不足：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。
3、更新判断 建立一张表，插入一条语句，定期执行更新语句。
4、内部统计  MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。
推荐方案：优先考虑 update 系统表，然后再配合增加检测 performance_schema 的信息

为什么有kill不掉的语句？
kill query/connection
原因1、线程没有执行到判断线程状态的逻辑
原因2、终止逻辑耗时较长（超大事务，等待 IO 资源，DDL 命令执行到最后阶段）
误解：
1，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。
2，如果库里面的表特别多，连接就会很慢 （MySQL 客户端会提供一个本地库名和表名补全的功能，是客户端慢，不是服务端慢）

查这么多数据，会不会把数据库内存打爆？
MySQL 是“边读边发的”，查询的结果是分段发给客户端的，查询返回大量的数据，并不会把内存打爆。在 server 层的处理
全表扫描对 InnoDB 的影响：
最近最少使用 (LRU) 算法，在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域，大表扫描时young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的查询命中率。

到底可不可以使用join？
Index Nested-Loop Join  近似复杂度：N + N*2*log2M。
Block Nested-Loop Join
把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；
扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。
（如果放不下表 t1 的所有数据话，策略很简单，就是分段（block）放）
小结：
如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；
如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。
总是应该使用小表做驱动表（在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。）

join语句怎么优化？
Index Nested-Loop Join优化：Multi-Range Read 优化（BKA算法）
因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能
MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。
Block Nested-Loop Join优化：
BNL 算法对系统的影响主要包括三个方面：
可能会多次扫描被驱动表，占用磁盘 IO 资源；
判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；
可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。
优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法。可以使用临时表

为什么临时表可以重名？
内存表与临时表：
内存表，指的是使用 Memory 引擎的表
临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的，当然，临时表也可以使用 Memory 引擎
临时表的特性：
1、只能被创建它的 session 访问，对其他线程不可见；
2、临时表可以与普通表同名；
3、session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表；
4、show tables 命令不显示临时表
临时表的应用：分库分表的场景
为什么临时表可以重名：
MySQL 要给临时表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}_{线程 id}_ 序列号”
在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；
而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据

什么时候会使用内部临时表？
union 执行流程
group by 执行流程
MySQL 什么时候会使用内部临时表：
如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；
如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。

都说InnoDB好，那还要不要使用Memory引擎？
innodb与Memory的区别：
1、InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的
2、当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；
3、数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引
4、InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的
5、InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。
6、Memory 引擎支持 hash 索引，内存表不支持行锁，只支持表锁

自增主键为什么不是连续的？
导致自增主键 id 不连续的原因：
唯一键冲突，事务回滚,批量插入时会预先申请多个自增id

怎么最快地复制一张表？
1、物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，
然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：
-必须是全表拷贝，不能只拷贝部分数据；
-需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；
-由于是通过拷贝物理文件实现的，源表和目标表都是使用 InnoDB 引擎时才能使用。
2、用 mysqldump 生成包含 INSERT 语句文件的方法，可以在 where 参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用 join 这种比较复杂的 where 条件写法。
3、用 select … into outfile 的方法是最灵活的，支持所有的 SQL 写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。
后两种方式都是逻辑备份方式，是可以跨引擎使用的。

grant之后要跟着flush privileges吗？
grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。
对于一个已经存在的连接，它的全局权限不受 grant 命令的影响。
flush privileges 命令会清空 acl_users 数组，然后从 mysql.user 表中读取数据重新加载，重新构造一个 acl_users 数组
如果内存的权限数据和磁盘数据表相同的话，不需要执行 flush privileges。而如果我们都是用 grant/revoke 语句来执行的话，内存和数据表本来就是保持同步更新的。
因此，正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令。

要不要使用分区表？
MySQL 在第一次打开分区表的时候，需要访问所有的分区（如果要使用分区表，就不要创建太多的分区）；
在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁；
在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区。
分区表的应用场景：
分区表的一个显而易见的优势是对业务透明，
相对于用户分表来说，使用分区表的业务代码更简洁。
还有，分区表可以很方便的清理历史数据。

自增id用完怎么办？
1、表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。
2、row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。
3、Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。
4、InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，所以我们文章中提到的脏读的例子就是一个必现的 bug，好在留给我们的时间还很充裕。
5、thread_id 是我们使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。

explain 详解：
id:
    id列的编号是select的序列号，有几个select就有几个id，并且id的顺序是按select出现的顺序增长的。
    id越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。
select type:
    表示对应行是简单还是复杂的查询。
        simple：简单查询。查询不包含子查询和union。
        primary：复杂查询中最外层的select
        subquery：包含在select中的子查询（不在from子句中）
        derived：包含在from子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表。
        union：在union关键字随后的selelct。
table:
    这一列表示explain的一行正在访问哪个表。
    当from子句中有子查询时，table列是格式，表示当前查询依赖id=N的查询，于是先执行id=N的查询。
    当有union时，UNION RESULT的table列的值为<union 1,2>，1和2表示参与union的select行id。
type:
    这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行对应的大概范围。
    依次从最优到最差的分别为：system>const>eq_ref>ref>range>index>All
    一般来说，得保证查询达到range级别，最好达到ref。
        NULL：MySQL能够在优化阶段分解查询语句，在执行阶段用不着在访问表或索引。
        const、system：mysql能对查询的某部分进行优化并将其转换成一个常量（可看成是show warnings的结果）。用于primay key或unique key的所有列与常数比较时，
        所以表最多有一个匹配行，读取1次，速读较快。system 是const的特例，表中只有一行元素匹配时为system。
        eq_ref：primay key或 unique key索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是const之外最好的联接类型，简单的select查询不会出现这种type。
        ref：相比eq_ref，不适用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行
        range：范围扫描通常出现在in(), between,>,<,>=等操作中。使用一个索引来检索给定范围的行。
        index：扫描全表索引，通常比All快一些
        all：即全表扫描，意味着MySQL需要从头到尾去查找所需要的行。这种情况下需要增加索引来进行优化。
possible_keys:
    这一列显示select可能会使用哪些查询来查找。
        explain时可能会出现possible_keys有列，而key显示为NULL的情况，这种情况是因为表中的数据不多，MySQL认为索引对此查询帮助不大，选择了全表扫描。
        如果该列为NULL，则没有相关的索引。这种情况下，可以通过检查where子句看是否可以创造一个适当的索引来提高查询性能，然后用explain查看效果。
key:
    这一列显示MySQL实际采用哪个索引对该表的访问。
        如果没有使用索引，则改列为NULL。如果想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用force index、 ignore index。
key_len:
    这一列显示了mysql在索引里使用的字节数，通过这个值可以估算出具体使用了索引中的哪些列。
ref:
    这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有： const(常量)，字段名等。一般是查询条件或关联条件中等号右边的值，如果是常量那么ref列是const，非常量的话ref列就是字段名。
row:
    这一列是mysql估计要读取并检测的行数，注意这个不是结果集的行数。
extra:
    这一列是额外信息。
        using filesort: mysql使用了一个外部的排序，无法使用索引的顺序进行读取，要尽量避免filesort；
        using temporary: 使用了临时表保存中间结果，常见于order by和group by（group by 后面的字段尽量和索引的顺序相同）；尽量避免temporary；
        using index: 表示使用到了覆盖索引；
        using where：表示使用了where过滤查询；
        using join buffer: 使用了连接缓存；
        impossible where: where 子句的值总是false，不能用来获取元组

适合建索引的列：where、order by、group by、distinct、join；
区分度越高，字段长度越小，使用最频繁的列放在最左侧

sql优化点：
1.尽量不使用select *；
2.尽量不使用子查询，可以优化为join操作（子查询会产生大量的临时表也没有索引，会消耗过多的CPU和IO资源，产生大量的慢查询）；
3.不要join太多表；
4.用in代替or；（in的值不能超过500个，in操作可以更有效的利用索引，or大多数情况下很少能利用到索引）；
5.where 从句中尽量不要对列进行函数转换和计算；
6.在明显不会有重复值时使用union all 而不是union；（union会把两个结果集的所有数据放到临时表中后再进行去重操作，union all不会对结果进行去重）；
7.拆分复杂的大sql为多个小sql；

索引失效场景：
1.被索引字段发生了隐式类型转换；
2.被索引字段使用了表达式；
3.被索引字段使用了函数；
4.like后面使用了左匹配"%s";
5.被索引字段不是联合索引的第一个

行锁：
    行锁分为共享锁（读锁）和排他锁（写锁）
    必须要有索引才能实现行锁（有索引就能快速定位到这个行，没有索引数据库也不能及时锁住行，需要扫描全表，为了安全起见只能锁住全表），两个事务不能同时对同一个
    行锁作用在读已提交和可重复读事务隔离级别下；
    行锁是存储引擎实现的，不是mysql提供的；
    对于update、delete和insert语句，innodb会自动给涉及的语句加上排他锁

Mysql调优：
    表和字段的设计，存储引擎的选择；
    利用好索引；
    分库分表，读写分离；
    sql优化

Mysql问题诊断：
    使用show processList查看当前所有的连接信息；
    使用explain 查询语句 查询sql的执行计划；
    开启慢日志查询，查看慢sql

















